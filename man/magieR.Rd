% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/magieR.R
\name{magieR}
\alias{magieR}
\alias{magieR,ANY-method}
\alias{magieR,SingleCellExperiment-method}
\alias{magieR,Seurat-method}
\title{magieR
Run magic with R}
\usage{
magieR(x, ...)

\S4method{magieR}{ANY}(
  x,
  genes = NULL,
  knn = 5,
  knn.max = NULL,
  decay = 1,
  t = 3,
  npca = 100,
  solver = "exact",
  t.max = 20,
  knn.dist.method = "euclidean",
  verbose = 1,
  n.jobs = 1,
  seed = NULL,
  ...
)

\S4method{magieR}{SingleCellExperiment}(x, assay = "logcounts", altExpName = "magic", ...)

\S4method{magieR}{Seurat}(x, slot = "data", assayName = "magic", ...)
}
\arguments{
\item{x}{A matrix with genes as columns and observations as rows.
Alternatively, a \linkS4class{SingleCellExperiment}  or a \linkS4class{Seurat} object.
For the SingleCellExperiment and Seurat methods, further arguments to pass to the ANY method.}

\item{genes}{character or integer vector, default: NULL
vector of column names or column indices for which to return smoothed data
If 'all_genes' or NULL, the entire smoothed matrix is returned}

\item{knn}{int, optional, default: 5
number of nearest neighbors on which to compute bandwidth}

\item{knn.max}{int, optional, default: NULL
maximum number of neighbors for each point. If NULL, defaults to 3*knn}

\item{decay}{int, optional, default: 1
sets decay rate of kernel tails.
If NULL, alpha decaying kernel is not used}

\item{t}{int, optional, default: 3
power to which the diffusion operator is powered
sets the level of diffusion. If 'auto', t is selected according to the
Procrustes disparity of the diffused data.'}

\item{npca}{number of PCA components that should be used; default: 100.}

\item{solver}{str, optional, default: 'exact'
Which solver to use. "exact" uses the implementation described
in van Dijk et al. (2018). "approximate" uses a faster implementation
that performs imputation in the PCA space and then projects back to the
gene space. Note, the "approximate" solver may return negative values.}

\item{t.max}{int, optional, default: 20
Maximum value of t to test for automatic t selection.}

\item{knn.dist.method}{string, optional, default: 'euclidean'.
recommended values: 'euclidean', 'cosine'
Any metric from `scipy.spatial.distance` can be used
distance metric for building kNN graph.}

\item{verbose}{`int` or `boolean`, optional (default : 1)
If `TRUE` or `> 0`, print verbose updates.}

\item{n.jobs}{`int`, optional (default: 1)
The number of jobs to use for the computation.
If -1 all CPUs are used. If 1 is given, no parallel computing code is
used at all, which is useful for debugging.
For n_jobs below -1, (n.cpus + 1 + n.jobs) are used. Thus for
n_jobs = -2, all CPUs but one are used}

\item{seed}{int or `NULL`, random state (default: `NULL`)}

\item{assay}{An integer scalar or string specifying the assay of \code{x} containing the logcount matrix.}

\item{altExpName}{A string specifying the alternative Experiment where the resulting magic matrix is stored in.
See \link{SingleCellExperiment::altExps}}

\item{slot}{A string specifying the slot of \code{x} containing the logcount matrix.}

\item{assayName}{A string specifying the new Assay where the resulting magic matrix is stored in.}
}
\description{
magieR
Run magic with R
}
\author{
Maximilian Heeg
}
